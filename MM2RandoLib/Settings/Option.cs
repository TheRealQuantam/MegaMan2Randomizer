using MM2Randomizer.Random;
using MM2Randomizer.Settings;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace MM2RandoLib.Settings.Options;

/// <summary>
/// Specifies that a class/field in an option group is itself an option group that should be inspected.
/// </summary>
[AttributeUsage(AttributeTargets.Class 
    | AttributeTargets.Struct 
    | AttributeTargets.Field 
    | AttributeTargets.Property)]
public sealed class OptionGroupAttribute : Attribute
{
    public bool IsCosmetic { get; init; } = false;
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public sealed class SaveOptionAttribute : Attribute
{
    public readonly bool Save;

    public SaveOptionAttribute(bool save = true) => Save = save;
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public sealed class TooltipAttribute : Attribute
{
    public readonly string Tooltip;

    public TooltipAttribute(string tooltip) => Tooltip = tooltip;
}


/// <summary>
/// Specifies whether the control for the option should be autogenerated. By default controls are created for options.
/// </summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public class CreateControlAttribute : Attribute
{
    public readonly bool CreateControl;

    public CreateControlAttribute(bool createControl = true) => CreateControl = createControl;
}

public class NoCreateControlAttribute : CreateControlAttribute
{
    public NoCreateControlAttribute() : base(false)
    {
    }
}

/// <summary>
/// Allows custom properties to be specified for autogenerated controls.
/// </summary>
[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
public sealed class ControlPropertyAttribute<T> : Attribute
{
    public readonly string Name;
    public readonly T Value;

    public ControlPropertyAttribute(string name, T value)
    {
        Name = name;
        Value = value;
    }
}

/// <summary>
/// Allows custom properties to be specified for autogenerated controls.
/// </summary>
[AttributeUsage(AttributeTargets.Field)]
public sealed class ControlPropertiesAttribute : Attribute
{
    public readonly IReadOnlyDictionary<string, object> Properties;

    public ControlPropertiesAttribute(
        IEnumerable<KeyValuePair<string, object>> properties)
        => Properties = new Dictionary<string, object>(properties);
}

public interface IOption : INotifyPropertyChanged
{
    Type Type { get; }
    OptionInfo? Info { get; set; }

    object DefaultValue { get; }

    bool Randomize { get; set; }
    object BaseValue { get; set; }

    bool Override { get; set; }
    bool OverrideRandomize { get; set; }
    object OverrideValue { get; set; }

    object Value { get; set; }

    bool EffectiveRandomize { get; set; }
    object EffectiveValue { get; set; }

    object ParseType(string value);

    void Actualize(ISeed seed);
}

public interface IEnumOption : IOption
{
    IReadOnlyList<object> EnumValues { get; }
    IReadOnlyDictionary<object, int> EnumValueIdcs { get; }

    /*int BaseValueIndex { get; set; }
    int EffectiveValueIndex { get; set; }*/
}

public abstract class Option<T> : IOption
    where T : notnull
{
    public Type Type => typeof(T);

    public OptionInfo? Info
    {
        get => _info;
        set => SetPropertyValue(ref _info, value);
    }

    public event PropertyChangedEventHandler? PropertyChanged;

    /// <summary>
    /// The default value of the option when it was not previously set.
    /// </summary>
    public readonly T DefaultValue;
    object IOption.DefaultValue => DefaultValue;

    /// <summary>
    /// Whether to choose the actual value randomly.
    /// </summary>
    public bool Randomize 
    {
        get => _randomize;
        set => SetPropertyValue(ref _randomize, value);
    }

    /// <summary>
    /// The value as set by the user. This may be overridden by Randomize and OverrideValue.
    /// </summary>
    public T BaseValue 
    {
        get => _baseValue;
        set => SetPropertyValue(ref _baseValue, value);
    }
    object IOption.BaseValue 
    { 
        get => BaseValue; 
        set => BaseValue = (T)value; 
    }

    /// <summary>
    /// If enabled, OverrideValue will be returned as Value regardless of Randomize and BaseValue.
    /// </summary>
    public bool Override 
    {
        get => _override;
        set => SetPropertyValue(ref _override, value);
    }
    public bool OverrideRandomize 
    {
        get => _overrideRandomize;
        set => SetPropertyValue(ref _overrideRandomize, value);
    }
    public T OverrideValue 
    {
        get => _overrideValue;
        set => SetPropertyValue(ref _overrideValue, value);
    }
    object IOption.OverrideValue
    {
        get => OverrideValue;
        set => OverrideValue = (T)value;
    }

    public bool EffectiveRandomize
    {
        get => _effectiveRandomize;
        set
        {
            if (!_override)
                Randomize = value;
        }
    }
    public T EffectiveValue
    {
        get => _effectiveValue;
        set
        {
            if (!_override)
                BaseValue = value;
        }
    }
    object IOption.EffectiveValue { 
        get => EffectiveValue; 
        set => EffectiveValue = (T)value; 
    }

    /// <summary>
    /// The real value of the option to be used when generating the seed.
    /// </summary>
    public T Value
    {
        get => _value;
        set => SetPropertyValue(ref _value, value);
    }
    object IOption.Value
    {
        get => Value;
        set => Value = (T)value;
    }

    protected OptionInfo? _info = null;

    protected bool _randomize;
    protected T _baseValue;

    protected bool _override;
    protected bool _overrideRandomize;
    protected T _overrideValue;

    protected bool _effectiveRandomize;
    protected T _effectiveValue;

    protected T _value;

    public Option(T defaultValue)
    {
        DefaultValue = _baseValue = _overrideValue = _effectiveValue = _value = defaultValue;
        _randomize = _override = _overrideRandomize = _effectiveRandomize = false;
    }

    public override string ToString()
    {
        string ovrStr = _override ? $", Ovr = {_overrideRandomize},{_overrideValue}" : "";
        return $"{_value}, Def = {DefaultValue}, Rnd = {_randomize}, Val = {_baseValue}{ovrStr}, ERnd = {_effectiveRandomize}, EVal = {_effectiveValue}";
    }

    public abstract T ParseType(string value);
    object IOption.ParseType(string value) => ParseType(value);

    public void Actualize(ISeed seed)
    {
        Value = (_override ? _overrideRandomize : _randomize)
            ? GetRandomizedOption(seed)
            : (_override ? _overrideValue : _baseValue);
    }

    protected abstract T GetRandomizedOption(ISeed seed);

    protected void UpdateEffective()
    {
        bool rnd = _override ? _overrideRandomize : _randomize;
        if (rnd != _effectiveRandomize)
        {
            _effectiveRandomize = rnd;
            NotifyPropertyChanged(nameof(EffectiveRandomize));
        }

        T value = _override ? _overrideValue : _baseValue;
        if (!value.Equals(_effectiveValue))
        {
            _effectiveValue = value;
            NotifyPropertyChanged(nameof(EffectiveValue));
        }
    }

    protected void NotifyPropertyChanged(
        [CallerMemberName] string propName = "")
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));
    }

    protected void SetPropertyValue<TProp>(
        ref TProp field,
        TProp value,
        [CallerMemberName] string propName = "")
    {
        Debug.Assert(propName != nameof(EffectiveRandomize)
            && propName != nameof(EffectiveValue));

        if ((value is not null && !value.Equals(field))
            || (value is null) != (field is null))
        {
            field = value;

            NotifyPropertyChanged(propName);
            UpdateEffective();
        }
    }
}

public class BoolOption : Option<bool>
{
    public BoolOption(bool value)
        : base(value)
    {
    }

    public override bool ParseType(string value) => bool.Parse(value);

    protected override bool GetRandomizedOption(ISeed seed)
        => seed.NextBoolean();
}

public class EnumOption<TEnum> : Option<TEnum>, IEnumOption
    where TEnum : struct, Enum
{
    public static readonly IReadOnlyList<TEnum> Values = Enum.GetValues<TEnum>();
    static readonly IReadOnlyList<object> ObjEnumValues = Values.Cast<object>().ToArray();
    IReadOnlyList<object> IEnumOption.EnumValues => ObjEnumValues;
    public IReadOnlyList<TEnum> EnumValues => Values;

    public static readonly IReadOnlyDictionary<TEnum, int> EnumValueIdcs = Values.Zip(Enumerable.Range(0, Values.Count)).ToDictionary();
    static readonly IReadOnlyDictionary<object, int> ObjEnumValueIdcs = EnumValueIdcs.ToDictionary(kv => (object)kv.Key, kv => kv.Value);
    IReadOnlyDictionary<object, int> IEnumOption.EnumValueIdcs => ObjEnumValueIdcs;

    /*public int BaseValueIndex
    {
        get => EnumValueIdcs[_baseValue];
    }*/


    public EnumOption(TEnum value)
        : base(value)
    {
    }

    public override TEnum ParseType(string value) => Enum.Parse<TEnum>(value);

    protected override TEnum GetRandomizedOption(ISeed seed) 
        => seed.NextEnum<TEnum>();
}

public class OptionInfo
{
    public readonly MemberInfo[] Path;
    public readonly string PathString;
    public readonly string GroupPathString;

    public readonly IOption Value;
    public readonly bool IsCosmetic;

    public string? Description { get; }
    public string? Tooltip { get; }
    public bool CreateControl { get; }

    public string Name => Path[^1].Name;
    public Type Type => Value.Type;

    public OptionInfo(IEnumerable<MemberInfo> path, IOption value, bool isCosmetic)
    {
        Path = path.ToArray();
        GroupPathString = string.Join(".", Path.Take(Path.Length - 1).Select(x => x.Name));
        PathString = string.Join(".", GroupPathString, Path[^1].Name);
        Value = value;
        IsCosmetic = isCosmetic;

        var fieldInfo = Path[^1];
        Description = fieldInfo
            .GetCustomAttribute<DescriptionAttribute>()?.Description;
        Tooltip = fieldInfo
            .GetCustomAttribute<TooltipAttribute>()?.Tooltip;
        CreateControl = fieldInfo
            .GetCustomAttribute<CreateControlAttribute>()?.CreateControl ?? true;
    }

    public Option<T> GetValue<T>() where T : notnull => (Option<T>)Value;

    public BoolOption BoolValue => (BoolOption)Value;

    public IEnumOption EnumOption => (IEnumOption)Value;

    public EnumOption<T> GetEnumOption<T>()
        where T : struct, Enum
        => (EnumOption<T>)Value;

    public override string ToString() => PathString;
}

public class OptionPreset
{
    public readonly IOption Option;
    public readonly bool Randomize;
    public readonly object Value;

    public OptionPreset(IOption option, bool randomize, object value)
    {
        Option = option;
        Randomize = randomize;
        Value = value;
    }

    public OptionPreset(BoolOption option, bool randomize, bool value) 
        : this((IOption)option, randomize, value)
    {
    }

    public OptionPreset(BoolOption option, bool value)
        : this(option, false, value)
    {
    }

    public override string ToString()
    {
        return $"{Option.Info?.Name}, {Randomize}, {Value}";
    }
}
